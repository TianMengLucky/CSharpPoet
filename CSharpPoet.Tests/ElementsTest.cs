namespace CSharpPoet.Tests;

public class CSharpTest
{
    [Fact]
    public void FileTest()
    {
        var file = new CSharpFile(new CSharpNamespace("TestNamespace")
        {
            Usings =
            {
                new CSharpUsing("NamespaceB"),
            },
        })
        {
            Usings =
            {
                new CSharpUsing("NamespaceA"),
                new CSharpUsing("NamespaceA.A") { IsGlobal = true, IsStatic = true },
                new CSharpUsing("AliasA", "NamespaceA"),
            },
        };

        Assert.Equal(
            "// <auto-generated>\n" +
            "\n" +
            "using NamespaceA;\n" +
            "global using static NamespaceA.A;\n" +
            "using AliasA = NamespaceA;\n" +
            "\n" +
            "namespace TestNamespace;\n" +
            "\n" +
            "using NamespaceB;\n" +
            "\n", file.ToString());
    }

    [Fact]
    public void EnumTest()
    {
        var @enum = new CSharpEnum("TestEnum", underlyingType: CSharpEnumUnderlyingType.SignedByte)
        {
            new("A"),
            new("B"),
            new("C", "10"),
        };

        Assert.Equal(
            "public enum TestEnum : sbyte\n" +
            "{\n" +
            "    A,\n" +
            "    B,\n" +
            "    C = 10,\n" +
            "}\n", @enum.ToString());
    }

    [Fact]
    public void StructTest()
    {
        var @struct = new CSharpStruct("TestStruct");

        Assert.Equal(
            "public struct TestStruct\n" +
            "{\n" +
            "}\n", @struct.ToString());
    }

    [Fact]
    public void RecordTest()
    {
        var record = new CSharpRecord("TestRecord");

        Assert.Equal(
            "public record TestRecord\n" +
            "{\n" +
            "}\n", record.ToString());
    }

    [Fact]
    public void ExtendsTest()
    {
        var @class = new CSharpClass("TestClass")
        {
            Extends = { "ITestInterface" },
        };

        Assert.Equal(
            "public class TestClass : ITestInterface\n" +
            "{\n" +
            "}\n", @class.ToString());
    }

    [Fact]
    public void NestedTest()
    {
        var @class = new CSharpClass("TestClass")
        {
            new CSharpClass("TestNested"),
        };

        Assert.Equal(
            "public class TestClass\n" +
            "{\n" +
            "    public class TestNested\n" +
            "    {\n" +
            "    }\n" +
            "}\n", @class.ToString());
    }

    [Fact]
    public void CommentTest()
    {
        var @class = new CSharpClass("TestClass")
        {
            new CSharpMultiLineComment(writer => writer.WriteLine("Test")),
            new CSharpBlankLine(),
            new CSharpComment(writer => writer.WriteLine("Test")),
        };

        Assert.Equal(
            "public class TestClass\n" +
            "{\n" +
            "    /*\n" +
            "     * Test\n" +
            "     */\n" +
            "\n" +
            "    // Test\n" +
            "}\n", @class.ToString());
    }

    [Fact]
    public void AttributeTest()
    {
        var @class = new CSharpClass("TestClass")
        {
            Attributes =
            {
                new CSharpAttribute("Test")
                {
                    new CSharpAttribute.Parameter("A"),
                    new CSharpAttribute.Parameter("b", "B"),
                    new CSharpAttribute.Property("C", "C"),
                },
            },
        };

        Assert.Equal(
            "[Test(A, b: B, C = C)]\n" +
            "public class TestClass\n" +
            "{\n" +
            "}\n", @class.ToString());
    }

    [Fact]
    public void FieldTest()
    {
        var @class = new CSharpClass("TestClass")
        {
            new CSharpField(Visibility.Internal, "int", "Field")
            {
                IsReadonly = true,
                IsStatic = true,
                DefaultValue = "1",
            },
        };

        Assert.Equal(
            "public class TestClass\n" +
            "{\n" +
            "    internal static readonly int Field = 1;\n" +
            "}\n", @class.ToString());
    }

    [Fact]
    public void MethodTest()
    {
        var @class = new CSharpClass("TestClass")
        {
            new CSharpMethod(Visibility.Private, "int", "Method")
            {
                IsStatic = true,
                Body = writer => writer.WriteLine("return 1;"),
            },
        };

        Assert.Equal(
            "public class TestClass\n" +
            "{\n" +
            "    private static int Method()\n" +
            "    {\n" +
            "        return 1;\n" +
            "    }\n" +
            "}\n", @class.ToString());
    }

    [Fact]
    public void PropertyTest()
    {
        var @class = new CSharpClass("TestClass")
        {
            new CSharpProperty("int", "AutoProperty")
            {
                Getter = new CSharpProperty.Accessor(),
                Setter = new CSharpProperty.Accessor(),
            },
            new CSharpProperty("int", "ExpressionProperty")
            {
                Getter = new CSharpProperty.Accessor
                {
                    Body = writer => writer.Write("1;"),
                },
            },
            new CSharpProperty("int", "StatementProperty")
            {
                Getter = new CSharpProperty.Accessor
                {
                    Body = writer => writer.Write("return 1;"),
                },
                Setter = new CSharpProperty.Accessor
                {
                    Body = writer => writer.Write("OnChanged(value);"),
                },
            },
        };

        Assert.Equal(
            "public class TestClass\n" +
            "{\n" +
            "    public int AutoProperty { get; set; }\n" +
            "    public int ExpressionProperty => 1;\n" +
            "    public int StatementProperty { get => return 1; set => OnChanged(value); }\n" +
            "}\n", @class.ToString());
    }
}
